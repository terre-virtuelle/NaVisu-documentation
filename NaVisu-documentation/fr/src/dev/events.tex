\chapter{Gestion des événements}


\section{Architecture}
\subsection{Principes}
1- Pour les objets en overlay, c'est du JavFX 

1.1 chargé depuis un fichier FXML :

quit.setOnMouseClicked((MouseEvent event) -> {
	instrument.off();
});

quit est ici un Button.

1.2 Héritant de Widget2DController, par exemple :

public class RouteEditorController
extends Widget2DController

Il y a déjà un comportement par défaut, apparition, disparition, déplacement, ... Voir le détail dans la classe Widget2DController, losr de l'instanciation on peut personnaliser le widget : 

routeEditorController = new RouteEditorController(this,
layersManagerServices ,
KeyCode.M, KeyCombination.CONTROL\_DOWN);
La touche M, permettra de faire disparaitre ce widget.

2- Pour les objets venant de WorldWind, c'est du Swing, il suffit de mettre l'objet WorldWindow à l'écoute d'un événement de sélection par exemple et de filtrer cet evt : 

2.1 Globalement :
\begin{verbatim}
private void addListeners() {
	wwd.addSelectListener((SelectEvent event) -> {
		Object o = event.getTopObject();
		if (event.isLeftClick() && o != null) {
			if (o.getClass() == PointPlacemark.class) {
				System.out.println("OK");
			}
		}
	});
}
\end{verbatim}
On voit ici que tous les objets de type PointPlacemark, au moins pour les couches sensibles aux événements, seront sélectionnés.
Pour réagir à cet evt, celà peut convenir pour afficher leur nom par exemple, mais pour pour une action spécifique, c'est sans doute trop général. Il faut donc filtrer des objets dont la vue est un PointPlacemark, mais qui ont un type particulier.

Une solution : créer la classe Poimark : 
\begin{verbatim}
public class Poimark extends PointPlacemark{
	
	public Poimark(Position pstn) {
		super(pstn);
	}
}
\end{verbatim}
Ensuite filtrer les Poimark : 
\begin{verbatim}
private void addListeners() {
	wwd.addSelectListener((SelectEvent event) -> {
		Object o = event.getTopObject();
		if (event.isLeftClick() && o != null) {
			if (o.getClass() == Poimark.class) {
				System.out.println("Action");
			}
		}
	});
}
\end{verbatim}
Enfin instancier des Poimark plutôt que de simples PointPlacemark :

\begin{verbatim}
public Set<Pair<Double, Double>> showPoi(Map<Pair<Double, Double>, String> data) {
	Set<Pair<Double, Double>> latLonSet = data.keySet();
	
	latLonSet.stream().map((ll) -> {
		String imageAddress = NavigationIcons.ICONS.get(ICON_NAME);
		
		Poimark poimark = new Poimark(Position.fromDegrees(ll.getX(), ll.getY(), 0));
		poimark.setAltitudeMode(WorldWind.CLAMP_TO_GROUND);
		poimark.setValue(AVKey.DISPLAY_NAME, data.get(ll));
		PointPlacemarkAttributes normalAttributes = new PointPlacemarkAttributes();
		normalAttributes.setImageAddress(imageAddress);
		normalAttributes.setScale(0.4);
		poimark.setAttributes(normalAttributes);
		return poimark;
	}).forEach((placemark) -> {
	sailingDirectionsIconsLayer.addRenderable(placemark);
});

return latLonSet;
}
\end{verbatim}